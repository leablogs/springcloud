package socket;import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicInteger;public class MyExecutorPool {    private String poolName;    private int coreSize = Runtime.getRuntime().availableProcessors();    private long keepLiveTime = 60L;    private TimeUnit unit;    private BlockingQueue<Runnable> workQueue;    private ThreadFactory threadFactory;    private RejectedExecutionHandler reject;    public MyExecutorPool(String poolName) {        this.poolName = poolName;        threadFactory = new MyThreadFactory(poolName);        workQueue = new ArrayBlockingQueue<Runnable>(100);    }    public MyExecutorPool() {        this.poolName = "Pool-0-thread";        threadFactory = new MyThreadFactory(poolName);        workQueue = new ArrayBlockingQueue<Runnable>(100);    }    public ThreadPoolExecutor startExecutor() {        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(coreSize, 2 * coreSize, keepLiveTime, TimeUnit.SECONDS, workQueue, threadFactory, new ThreadPoolExecutor.AbortPolicy());        threadPoolExecutor.prestartAllCoreThreads();        return threadPoolExecutor;    }    class MyThreadFactory implements ThreadFactory {        private AtomicInteger atomicInteger = new AtomicInteger(1);        private String threadName;        public MyThreadFactory(String threadName) {            this.threadName = threadName;        }        @Override        public Thread newThread(Runnable r) {            Thread thread = new Thread(r, threadName + "-" + atomicInteger.getAndIncrement());            if (!thread.isDaemon()) {                thread.setDaemon(true);            }            if (thread.getPriority() != Thread.NORM_PRIORITY) {                thread.setPriority(Thread.NORM_PRIORITY);            }            return thread;        }    }    class My implements RejectedExecutionHandler {        @Override        public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {        }    }}