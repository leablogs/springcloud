package socket.nio;/** * 改程序实现了简单的服务器 * 创建了serverSocketChannel和Selector对象，并将通道注册到选择器上 * 在不注册的键中保存服务器socket的饮用，因为他永远不会被注销 * 无线循环在最上面先调用了select(),这可能会无限期的阻塞 * 当选择结束时，就便利选择键并检查已经就绪的通道 * 通过对服务器select通道的饮用，调用了了accept（）方法，获取到达的socket句柄，并返回socketchannel对象 * 将socket注册到选择器上，通过传入的op_read标记，告诉选择器新的socket通道是什么时候可以准备好读取数据 */import lombok.extern.slf4j.Slf4j;import java.io.IOException;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;@Slf4jpublic class SelectSocket {    public static int PORT = 1234;    private final ByteBuffer buffer = ByteBuffer.allocateDirect(1024);    /*   public static void main(String[] args) throws IOException {           new SelectSocket().go(args);       }   */    public void go(String[] argv) throws IOException {        int port = PORT;        if (argv.length > 0) {            port = Integer.parseInt(argv[0]);        }        log.info("Listening on port:{}", port);        ServerSocketChannel serverChannel = ServerSocketChannel.open();        ServerSocket serverSocket = serverChannel.socket();        Selector selector = Selector.open();        serverSocket.bind(new InetSocketAddress(port));        serverChannel.configureBlocking(false);        serverChannel.register(selector, SelectionKey.OP_ACCEPT);        while (true) {            int n = selector.select();            if (n == 0) {                continue;            }            Iterator it = selector.selectedKeys().iterator();            while (it.hasNext()) {                SelectionKey key = (SelectionKey) it.next();                if (key.isAcceptable()) {                    ServerSocketChannel server = (ServerSocketChannel) key.channel();                    SocketChannel channel = server.accept();                    registerChannel(selector, channel, SelectionKey.OP_READ);                    sayHello(channel);                }                if (key.isReadable()) {                    readDataFromSocket(key);                }                it.remove();            }        }    }    private void readDataFromSocket(SelectionKey key) throws IOException {        SocketChannel socketChannel = (SocketChannel) key.channel();        int count;        buffer.clear();        while ((count = socketChannel.read(buffer)) > 0) {            buffer.flip();            while (buffer.hasRemaining()) {                socketChannel.write(buffer);            }            buffer.clear();        }        if (count < 0) {            socketChannel.close();        }    }    private void sayHello(SocketChannel socketChannel) throws IOException {        buffer.clear();        buffer.put("Hi there!\r\n".getBytes());        buffer.flip();        socketChannel.write(buffer);    }    private void registerChannel(Selector selector, SocketChannel channel, int ops) throws IOException {        if (channel == null) {            return;        }        channel.configureBlocking(false);        channel.register(selector, ops);    }}