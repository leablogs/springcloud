package socket.nio;import lombok.extern.slf4j.Slf4j;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.SocketChannel;import java.util.LinkedList;import java.util.List;@Slf4jpublic class SelectSocketThreadPool extends SelectSocket {    private static final int MAX_THREAD = 5;    private ThreadPool pool = new ThreadPool(MAX_THREAD);    public static void main(String[] args) throws IOException {        new SelectSocketThreadPool().go(args);    }    protected void readDataFromSocket(SelectionKey key) {        WorkerThread worker = pool.getWorker();        if (worker == null) {            return;        }        worker.serviceChannel(key);    }    private class ThreadPool {        List idle = new LinkedList();        public ThreadPool(int maxThread) {            for (int i = 0; i < maxThread; i++) {                WorkerThread thread = new WorkerThread(this);                thread.setName("Worker" + (i + 1));                thread.start();                idle.add(thread);            }        }        public WorkerThread getWorker() {            WorkerThread workerThread = null;            synchronized (idle) {                if (idle.size() > 0) {                    workerThread = (WorkerThread) idle.remove(0);                }            }            return workerThread;        }        void returnWorker(WorkerThread workerThread) {            synchronized (idle) {                idle.add(workerThread);            }        }    }    private class WorkerThread extends Thread {        private ByteBuffer buffer = ByteBuffer.allocate(1024);        private ThreadPool pool;        private SelectionKey key;        public WorkerThread(ThreadPool threadPool) {            this.pool = threadPool;        }        @Override        public synchronized void run() {            log.info("{} is ready", this.getName());            while (true) {                try {                    this.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }                if (key == null) {                    continue;                }                log.info("{} has been awakened", this.getName());                try {                    drainChannel(key);                } catch (Exception e) {                    log.info("Caught{} closing channel", e);                    try {                        key.channel().close();                    } catch (IOException ex) {                        ex.printStackTrace();                    }                    key.selector().wakeup();                }                key = null;                this.pool.returnWorker(this);            }        }        private void drainChannel(SelectionKey key) throws IOException {            SocketChannel channel = (SocketChannel) key.channel();            int count;            buffer.clear();            while ((count = channel.read(buffer)) > 0) {                buffer.flip();                while (buffer.hasRemaining()) {                    channel.write(buffer);                }                buffer.clear();                if (count < 0) {                    channel.close();                    return;                }                key.interestOps(key.interestOps() | SelectionKey.OP_READ);                key.selector().wakeup();            }        }        public void serviceChannel(SelectionKey key) {            this.key = key;            key.interestOps(key.interestOps() & (~SelectionKey.OP_READ));            this.notify();        }    }}