package threads.eruptsimultaneously;import threads.product_comsumer.P;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.AbstractQueuedSynchronizer;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;/** * 只允许之多两个线程同时访问，超过两个线程访问将被阻塞 * * */public class TwinsLock implements Lock {	private final Sync sync = new Sync(2);	private static final class Sync extends AbstractQueuedSynchronizer {		Sync(int count) {			if (count <= 0) {				throw new IllegalArgumentException("count must large than zero");			}			setState(count);		}		/**		 * 同步器会先计算出获取后的同步状态，然后再通过CAS确保状态正确设置，		 * 返回值大于0，获取同步状态，		 * @param reduceCount		 * @return		 */		public int tryAcquireShared(int reduceCount) {			for (; ; ) {				int current = getState();				int newCount = current - reduceCount;				if (newCount < 0 || compareAndSetState(current, newCount)) {					return newCount;				}			}		}		public boolean tryReleaseShared(int returnCount) {			for (; ; ) {				int current = getState();				int newCount = current + returnCount;				if (compareAndSetState(current, newCount)) {					return true;				}			}		}		Condition newCondition() {			return new ConditionObject();		}	}	public void lock() {		sync.acquireShared(1);	}	@Override	public void lockInterruptibly() throws InterruptedException {		sync.acquireSharedInterruptibly(1);	}	@Override	public boolean tryLock() {		return sync.releaseShared(1);	}	@Override	public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {		return sync.tryAcquireSharedNanos(1, unit.toNanos(time));	}	public void unlock() {		sync.releaseShared(1);	}	@Override	public Condition newCondition() {		return sync.newCondition();	}}