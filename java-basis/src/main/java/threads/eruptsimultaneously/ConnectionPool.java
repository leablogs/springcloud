package threads.eruptsimultaneously;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.sql.Connection;import java.util.LinkedList;import java.util.concurrent.TimeUnit;/** * 等待超时模式模拟数据库连接池 * 构造函数初始化连接最大上限 * 通过一个双向队列维护连接 * fetch 指定在多少毫秒内超时获取连接 * releaseConnection 将连接放回线程池 */public class ConnectionPool {    private LinkedList<Connection> pool = new LinkedList<Connection>();    public ConnectionPool(int initialSize) {        if (initialSize > 0) {            for (int i = 0; i < initialSize; i++) {                pool.addLast(ConnectionDriver.ConnectionHandler.createConnection());            }        }    }    /**     * @param connection     */    public void releaseConnection(Connection connection) {        if (connection != null) {            synchronized (pool) {                // 连接释放后需要进行通知，这样其他消费者才能感知到连接池已经归还了一个连接                pool.addLast(connection);                pool.notifyAll();            }        }    }    public Connection fetchConnection(long mills) throws InterruptedException {        synchronized (pool) {            if (mills < 0) {                while (pool.isEmpty()) {                    pool.wait();                }                return pool.removeFirst();            } else {                long future = System.currentTimeMillis() + mills;                long remaining = mills;                while (pool.isEmpty() && remaining > 0) {                    pool.wait();                    remaining = future - System.currentTimeMillis();                }                Connection result = null;                if (!pool.isEmpty()) {                    result = pool.removeLast();                }                return result;            }        }    }}class ConnectionDriver {    static class ConnectionHandler implements InvocationHandler {        @Override        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {            if (method.getName().equals("commit")) {                TimeUnit.MICROSECONDS.sleep(100);            }            return null;        }        public static final Connection createConnection() {            return (Connection) Proxy.newProxyInstance(ConnectionDriver.class.getClassLoader(),                    new Class[]{Connection.class}, new ConnectionHandler());        }    }}