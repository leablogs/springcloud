package threads.eruptsimultaneously;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.AbstractQueuedSynchronizer;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;/** * mutex 是一个自定义独占锁同步组件 * 同意时刻只允许一个线程占有锁， * 定义了静态内部类，该内部类继承了同步器并实现了独占式获取和释放同步状态 * <p> * 使用mutex 不会直接和内部同步器实现打交道，而是调用mutex提供方法， * <p> * 获取锁只需要在方法实现中调用同步器目标方法acquire即可，当该方法获取同步状态失败，被加入同步队列等待 * * 当线程调用lock方法时获取锁之后，再次调用lock方法，将被被自己阻塞，在实现tryAcquire * 方法时没有考虑再次过去锁的场景，而是返回了false导致线程阻塞 */public class Mutex implements Lock {    private final Sync sync = new Sync();    @Override    public void lock() {        sync.tryAcquire(1);    }    @Override    public void lockInterruptibly() throws InterruptedException {        sync.acquireInterruptibly(1);    }    public boolean isLocked() {        return sync.isHeldExclusively();    }    public boolean hasQueuedThreads() {        return sync.hasQueuedThreads();    }    @Override    public boolean tryLock() {        return sync.tryAcquire(1);    }    @Override    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {        return sync.tryAcquireNanos(1, unit.toNanos(time));    }    @Override    public void unlock() {        sync.tryRelease(1);    }    @Override    public Condition newCondition() {        return sync.newCondtion();    }    private static class Sync extends AbstractQueuedSynchronizer {        @Override        protected boolean isHeldExclusively() {            return getState() == 1;        }        /**         * 经过CAS设置成功，表示获取了同步状态         *         * @param arg         * @return         */        @Override        protected boolean tryAcquire(int arg) {            if (compareAndSetState(0, 1)) {                setExclusiveOwnerThread(Thread.currentThread());                return true;            }            return false;        }        /**         * 将同步状态重置0         *         * @param arg         * @return         */        @Override        protected boolean tryRelease(int arg) {            if (getState() == 0)                throw new IllegalMonitorStateException();            setExclusiveOwnerThread(null);            setState(0);            return true;        }        Condition newCondtion() {            return new ConditionObject();        }    }}