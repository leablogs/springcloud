package threads.lock;import oshi.annotation.concurrent.GuardedBy;import oshi.annotation.concurrent.ThreadSafe;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 有限缓存使用显示的条件变量 * * @param <T> */@ThreadSafepublic class ConditionBoundedBuffer<T> {	protected final Lock lock = new ReentrantLock();	private Integer BUFFER_SIZE = 0;	// not full count<items.length	private final Condition notFull = lock.newCondition();	// not empty (count>0)	private final Condition notEmpty = lock.newCondition();	@GuardedBy("lock")	private final T[] items = (T[]) new Object[BUFFER_SIZE];	@GuardedBy("lock")	private int tail, head, count;	// 阻塞直到notfull	public void put(T x) throws InterruptedException {		lock.lock();		try {			while (count == items.length) {				notFull.await();			}			if (++tail == items.length) {				tail = 0;			}			++count;			notEmpty.signal();		} finally {			lock.unlock();		}	}	// 阻塞直到notEmpty	public T take() throws InterruptedException {		lock.lock();		try {//            while (true){//                if(lock.tryLock()){//                    break;//                }//            }			while (count == 0) {				notEmpty.await();			}			T x = items[head];			items[head] = null;			if (++head == items.length) {				head = 0;			}			--count;			notFull.signal();			return x;		} finally {			lock.unlock();		}	}}@ThreadSafeclass SemaphoreOnLock {	private final Lock lock = new ReentrantLock();	// permitsAvailable (permits>0)	private final Condition permitsAvailable = lock.newCondition();	@GuardedBy("lock")	private int permits;	SemaphoreOnLock(int initialPermists) {		lock.lock();		try {			permits = initialPermists;		} finally {			lock.unlock();		}	}	// 阻塞 直到permitsAvailable	public void acquire() throws InterruptedException {		lock.lock();		try {			while (permits <= 0) {				permitsAvailable.await();			}			--permits;		} finally {			lock.unlock();		}	}	public void release() {		lock.lock();		try {			++permits;			permitsAvailable.signal();		} finally {			lock.unlock();		}	}	protected int tryAcquireShared(int acquires) {		while (true) {			int available = getState();			int remaining = available - acquires;			if (remaining < 0 || compareAndSetStatue(available, remaining)) {				return remaining;			}		}	}	protected boolean tryRelaseShared(int releases) {		while (true) {			int p = getState();			if (compareAndSetStatue(p, p + releases)) {				return true;			}		}	}	private boolean compareAndSetStatue(int available, int remaining) {		return true;	}	private int getState() {		return 0;	}}