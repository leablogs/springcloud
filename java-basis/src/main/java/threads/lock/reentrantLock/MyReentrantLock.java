package threads.lock.reentrantLock;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class MyReentrantLock {    public static void main(String[] args) throws InterruptedException {        MyService service = new MyService();//        MyThread a1 = new MyThread(service);//        MyThread a2 = new MyThread(service);//        MyThread a3 = new MyThread(service);//        MyThread a4 = new MyThread(service);//        MyThread a5 = new MyThread(service);//        MyThread a6 = new MyThread(service);//        a1.start();//        a2.start();//        a3.start();//        a4.start();//        a5.start();//        a6.start();        MyThreadA a = new MyThreadA(service);        a.setName("A");        a.start();        MyThreadAA aa = new MyThreadAA(service);        aa.setName("AA");        aa.start();        Thread.sleep(100);        MyThreadB b = new MyThreadB(service);        b.setName("B");        b.start();        MyThreadB bb = new MyThreadB(service);        bb.setName("BB");        bb.start();    }}class MyService {    private Lock lock = new ReentrantLock();    public void testMethod() {        lock.lock();        for (int i = 0; i < 5; i++) {            System.out.println("Thread name=" + Thread.currentThread().getName() + (" " + (i + 1)));        }        lock.unlock();    }    public void methodA() {        try {            lock.lock();            System.out.println("methodA begin thread name=" + Thread.currentThread().getName() +                    " time=" + System.currentTimeMillis());            Thread.sleep(5000);            System.out.println("methodA end Thread name=" + Thread.currentThread().getName() + " time=" + System.currentTimeMillis());        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    public void methodB() {        try {            lock.lock();            System.out.println("methodB begin thread name=" + Thread.currentThread().getName() +                    " time=" + System.currentTimeMillis());            Thread.sleep(5000);            System.out.println("methodB end Thread name=" + Thread.currentThread().getName() + " time=" + System.currentTimeMillis());        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }}class MyThread extends Thread {    private MyService myService;    MyThread(MyService myService) {        this.myService = myService;    }    @Override    public void run() {        myService.testMethod();    }}class MyThreadA extends Thread {    private MyService myService;    MyThreadA(MyService myService) {        this.myService = myService;    }    @Override    public void run() {        myService.methodA();    }}class MyThreadAA extends Thread {    private MyService myService;    MyThreadAA(MyService myService) {        this.myService = myService;    }    @Override    public void run() {        myService.methodA();    }}class MyThreadB extends Thread {    private MyService myService;    MyThreadB(MyService myService) {        this.myService = myService;    }    @Override    public void run() {        myService.methodB();    }}class MyThreadBB extends Thread {    private MyService myService;    MyThreadBB(MyService myService) {        this.myService = myService;    }    @Override    public void run() {        myService.methodB();    }}