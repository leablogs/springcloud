package threads;import oshi.annotation.concurrent.GuardedBy;import oshi.annotation.concurrent.ThreadSafe;import java.util.Collection;import java.util.Collections;import java.util.HashMap;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import java.util.regex.Pattern;/** * 通过优化同步代码块的范围来实现减少锁的竞争 */@ThreadSafepublic class BetterAttributeStore {    @GuardedBy("this")    private final Map<String, String> attributes = new HashMap<String, String>();    private final Map<String, String> getAttributes1 = Collections.synchronizedMap(attributes);    private final Map<String, String> getAttributes2 = new ConcurrentHashMap<String, String>();    /**     * 采用同步方法实现线程安全     * 仅仅     *     * @param name     * @param reg     * @return     */    public synchronized boolean userLocationMatches(String name, String reg) {        String key = "users." + name + ".location";        String location;        location = attributes.get(key);        if (location == null) {            return false;        } else {            return Pattern.matches(reg, location);        }    }    /**     * 优化后采用同步代码块实现线程安全     * 将不需要的移出同步代码     * 缩小了锁守护的范围，减少了调用中遇到锁的情况，串行化的代码少了     * <p>     * 可以使用代理线程安全技术，通过使用线程安全的map（hashtable synchronizedMap concurrenHashmap 取代attributes     *     * @param name     * @param reg     * @return     */    public boolean userLocationMatche1(String name, String reg) {        String key = "users." + name + ".location";        String location;        synchronized (this) {            location = attributes.get(key);        }        if (location == null) {            return false;        } else {            return Pattern.matches(reg, location);        }    }}