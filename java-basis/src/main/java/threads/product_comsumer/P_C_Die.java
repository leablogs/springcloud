package threads.product_comsumer;public class P_C_Die {    public static void main(String[] args) throws InterruptedException {        String lock = new String("");        P p = new P(lock);        C c = new C(lock);        ThreadP[] pThread = new ThreadP[2];        ThreadC[] cThread = new ThreadC[2];        for (int i = 0; i < 2; i++) {            pThread[i] = new ThreadP(p);            pThread[i].setName("生产者" + (i + 1));            cThread[i] = new ThreadC(c);            cThread[i].setName("消费者" + (i + 1));            pThread[i].start();            cThread[i].start();        }        Thread.sleep(5000);        Thread[] th = new Thread[Thread.currentThread().getThreadGroup().activeCount()];        Thread.currentThread().getThreadGroup().enumerate(th);        for (int i = 0; i < th.length; i++) {            System.out.println(th[i].getName() + " " + th[i].getState());        }    }    static class P {        private String lock;        public P(String lock) {            this.lock = lock;        }        public void setValue() {            try {                synchronized (lock) {                    while (!ValueObject.value.equals("")) {                        System.out.println("生产者" + Thread.currentThread().getName() + " WAITING了★");                        lock.wait();                    }                    System.out.println("生产者 " + Thread.currentThread().getName() + " Runnalbe了");                    String value = System.currentTimeMillis() + "_" + System.nanoTime();                    ValueObject.value = value;                    lock.notify();                }            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    static class C {        private String lock;        public C(String lock) {            this.lock = lock;        }        public void getValue() {            try {                synchronized (lock) {                    while (ValueObject.value.equals("")) {                        System.out.println("消费者" + Thread.currentThread().getName() + " WAITING了☆");                        lock.wait();                    }                    System.out.println("消费者 " + Thread.currentThread().getName() + " Runnalbe了---接收值：" + ValueObject.value);                    ValueObject.value = "";                    lock.notify();                }            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    static class ThreadP extends Thread {        private P p;        ThreadP(P p) {            this.p = p;        }        @Override        public void run() {            super.run();            while (true) {                p.setValue();            }        }    }    static class ThreadC extends Thread {        private C p;        ThreadC(C p) {            this.p = p;        }        @Override        public void run() {            super.run();            while (true) {                p.getValue();            }        }    }}